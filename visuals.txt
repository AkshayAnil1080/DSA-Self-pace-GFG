 Number of digits - logn+1 - O(1)
palindrome  =  0(d)
trailing zeros =  logn
GCD. -  naive : O(min(a,b) ) - Euclid -   - Opt Euclid - b==0 return a , else gcd(b,a%b) - O(logMIN(a,b))
LCM - Naive - (a*b - max(a,b) -   a*b  = gcd(a,b) *lcm(a,b)   O(logMIN(a,b))
Prime - 1. i=2;  i<n -O(n)  - 2. i=2;  i*i<n - O(sqrt(n))  
-3. 6n-1, 6n+1, check for n%2 and n%3 - i=5 ;i*i<=n;i=i+6 -if(n%i==0 || n%(i+2)==0) return false; 3 times faster than (sqrt(n))
Prime factors - 
1. i =2 ; i<n ; i++
	ifPrime(i) { x = i; while(n%x==0) { print(i); x=x*i;} }  - O(n^3/2 logn)
2. divisor - pair of prime factors - 
i =2 ; i*i<=n ; i++ { while(n%i==0) { print(i) ; n=n/i;}      - O(n^1/2 logn)
if(n>1) print(n);	
3. while(n%2==0) {print(2); n=n/2;}  while(n%3==0) {print(3); n=n/3;}  -  O(n^1/2)
i=5 ;i*i<=n;i=i+6 {
 while(n%i==0){print(i); n=n/i;}  while(n%i+2=0){print(i+2); n=n/i+2;}
		   } if(n>3) print(n)
All divisors of a Number
Naive - O(n) - 2. i=1; i*i<=n;i++ { if(n%i==0) {print(i) if(n!=n/i) print(n/i)} - O(n^1/2)
3. to print in sorted way - O(n^1/2  + n^1/2)

Seive of Eratosthenese -  p 
1. Naive - O(n*n^1/2) 
2. seive - a. boolean isPrime[] = new boolean[n+1]; Arrays.fill(isPrime,true);
	   b. for(i=2; i*i<=n;i++) { if(isPrime(i)); //mark  the mutiples of this prime number as false - for(int j=2*i; i*i<=n ;j=j+i) { isPrime[j]==false; }

Compute Power - 
1. Naive -  O(n)
2. b==0 return 0 ; temp = pow(a,b/2) ; temp *=temp ; if(b odd) a*temp; else temp;
3. while(n>0) { if(n%2==0) {res=res*x;} x*=x ; n=n/2  } return res;


arraYS - in java- always in heap segment
1. LINEAR - inset -O(n) : Search-O(n) for unsoted, o(logn) for sorted : Delete -O(n)
2. LARGEST-  O(n)
3. SECOND LARGEST -1. Naive(nlogn) - 2. largest(n) + second loop(arr[i]!=arr[largest])(n) :O(2n)  -
	3. a[i] >a[largest] : res =largest , largest=i      - O(n)
   	a[i] == a[largest] igore
   	a[i]!=a[largest] - > a[i]<a[largest] => res = -1, res=i;
		    - > a[i]<=a[res] 	=> ignore
		    - > a[i]>a[res]	=> res =i;
4. CHECK IF ARRAY IS SORTED i=1 ; i<n -> if(arr[i-1]>arr[i]) return false = O(n)

. REVERSE AN ARRAY AND UPDATE THE SAME - > swap (1 ans last), (2 and 2nd last) ... while(low<high) {swap(a[low],a[high]) low++;high--;}  - O(n),O(1)
6. REMOVE DUP FROM SORTED ARR-> 1. print every ele in hash and print it O(n),O(n) -> 2. create temp[] - copy distinct of arr in temp - update arr witht temp O(n),O(n) -> .
   3.res=1 - i=1;i<n - arr[i]!=arr[res-1] { arr[res]=arr[i]; res++} - O(n),O(1)

7. MOVE ALL ZEROS TO END -> 1. Naive - for each zero(i=0;i<n) at i -search next non-zero(j=i+1;j<n) j - swap a[i],a[j]  -O(n^2),O(1) 
   2. keep track of non-zere ele. c =0; for(i=0;i<n;) {if(a[i]!=0) swap(a[i],c) ; c++; }

8. LEFT ROATATE ARR BY ONE(D) - 1. reverse(arr,0,d-1) reverse(arr,d,n-1) reverse(arr,0,n)  - for reverse use while high,low.
9. LEADERS IN ARRAY(At i, all rights should be smaller)  - O(n^2)   - O(n) -  start from right(rightmost always will be leader)
10. MAXIMUM DIFFERENCE - 
11. FREQUENCIES IN SORTED ARRAY - O(n ) -  if unsorted - sort+O(n) - O(nlogn) => if unsorted - O(n) - put in map, value ++
12 SELL AND BUT STOCK - O(n^2) - O(n)keep on adding the profit of cumulative number
13. TRAPPING RAINWATER  - O(n^2)for every i traverse Min(leftmax and rightmax) -arr[i]   - O(n),O(n) -store lmax[i], rmax[i] , res+=min(lmax[i],rmax[i] -a[i])
14. MAXIMUM CONS 1's  - O(n)
15. MAXIMUM SUBARRAY -  KADANES - O(n)
	-3 , 8 ,  -2,   4 ,    -5,     6				for(i=1;i<n;i++) { maxE=Math.max(maxE+arr[i], arr[i]);  //update res=Math.max(res,maxE); }
maxE	  (5,8),(6,-2),(10,4),(5,-5),(11,6)
res	    8  , 8    , 10   , 10   , 11
16. MAX LENGTH EVEN _ODD SUBARR - kadanes - O(n)
17. MAX CIRCULAR SUB ARRAY-  O(n),O(1) - max_normal-kadanes(arr,n) , max_circular=(arr_sum + kadanes(inverted_arr, n) -> return max(max_normal, max_circular)
18. Majority Element - O(n),O(1) -find a candidate, check if its count >n/2.
19. MINIMUM CONSECUTIVE FLIPS - O(n),O(1) - count 1, 0's count =n-(1's count) - comapre which is less that needs to be flipped.
20. SLIDING WINDOW TECHNIQUE - 
    find max sum of k consecutive ele - O(n^2)-  cal sum for every window.
					O(n) - sum of curr window = sum of prev window - (first ele of prev window)  + (last ele of curr wind)
21. FIND IF THERE IS SUBARR WITH GIVEN SUM -
	1. O(n^2) - array 
	2. hashmap -O(n)
	3. O(n) - array - for =ve ele only - > s= 0; for( e=1 ;e<n ;e++) { a.while(curr_sum>sum && s<e-1){curr_sum+=arr[i];s++;}  b. if(curr_sum==sum) true; c.if (e<n) curr_sum+=arr[e] }
22. PREFIX SUM : 
	Calcualte prefix sum : for( i=1; i<n;i++) {prefixsum[i] = prefixsum[i-1] +a[i];}  - O(n)
	Requirement: getsum(l,r) in O(1) - if(l!=0) prefixsum[r] - prefixsum[l-1]  , if(l==0) prefixsum[r]; 
23. FIND IF ARR HAS EQUILIBRIUM POINT - any point in arr which has left sum == right sum	
	O(n^2) - calculate l_sum , r_sum for each point
	O(n) - 1. compute total sum 2. for(i=0;i<n;i++){ a. if(lsum=sum-a[i]) ret true;  lsum+=a[i] ;sum-=a[i];} ret false;
	
24. Given n ranges , find maximum appearing element in these ranges
	O(n) - 1. arr[L[i]]++; arr[R[i]+1]--; for(i=1;i<1000;i++) { arr[i]+=arr[i-1]; if(max<arr[i]){max =  arr[i] ;res =i;}  } return res; 


RECUSRSION
1. PRINT DECMAL TO BINARY
2. TAIL(eff, eg Quick sort, inO , preO) AND NON TAIL RECUSRION(ineff ,recusrion is not the last step, Eg merge sort, postO)
3. FACTORIAL -  if(n==0 || n==1) ret 1; ret n*fact(n-1) - NTR
	
		k= 1; fact( int n , int k){ if(n==0|| n==1) ret k ; ret fact(n-1,k-1); }  - TR
4. FIBONACCI - if(n<=1) ret n ; ret fin(n-1) + fib(n-2);
5. SUM OF NATIURAL NUMBERS
6. PALINDROME CHECK -  
7. SUM OF DIGITS USING RECUSRION -
8. ROPE CUTTING
9. GENERATE SUBSETS
10. TOH  - O(2^n) - 
11. JOSEPHUS PROB - in jos( int n, int k) { if(n==1) return 0;  return (jos(n-1,k) +k)%n; }  T(n) =  T(n-1) + theta(1) = O(n)
12. SUBSET SUM PROBLEM - O(2^n) int cs( int a[] , int n, int sum) { if(n==0) ret(sum==)?1:0; ret cs(a, n-1, sum) + cs(a, n-1,sum-a[n-1]); }
13. PRINT PERMUTATION OF ALL STRING - 


Searching - 3 times
To Do:   Median of two soted arrays
	Allocation of minimum nuber of pages
1. Binary Search - while(l<=h) { int m =l+h/2 ; if(a[m] ==x) ret mid; else if(a[m]<x) l=m+1; else h=m+1;  }  TC : 0(logn) ASC : O(1)
		 - { m = l+h/2; if(a[m] ==x) ret m ; else if ret BSearch(a,l,m-1,x); else ret Bsearch(a,m+1,h,x); } TC:O(logn) ASC:O(logn)

2. Index of first Occurence(sorted arr) -1. naive- Linear -O(n)  2. binary search + if(a[m]==x) { if(m==0 || a[m-1]!=a[m]) ret m; else high =m-1;}    
3. Index of Last Occurence(sorted arr) - 1. naive- Linear -O(n)  2. binary search + if(a[m]==x) { if(m==n-1 || a[m+1]!=a[m]) ret m ; else low =m+1;}
4. COUNT OCCURENCE IN SORTED - 1. Naive -Linear -O(n)  2. binary Search find first(i) and last(j) occ index -  ret j-i+1   - O(2logn)
5. COUNT OCC OF 1 - arr[0,0,0,1,1,1] - 1. BS - cond1. - arr[m] ==0   ; low= m+1 
					       cond2  -	arr[m] ==1 -> left of arr[m] is 0  : ret n-m; ->  else left of a[m] is 1 : high =m-1;
6. SQrt of X - 1. while(i*i<=x) i++ : O(x^1/2)  2. BS -O(logx) - while(l<=h) { if(m*m == x) ret m ; if(m*m >x) high =m-1; else { l= m+1; ans=m'}  }
7. SEARCH IN INFINITE SORTED ARRAY - 1. Naive - O(pos) while(true) if a[i]==x ret i; ifa[i] >x ret -1; i++;
				     2. BS - O(logPos) check for i=0 , else
						       int i=1; while(arr[i] <x) { i=i*2; } if(arr[i] ==x) ret i;  else ret BS(arr, x, i/2+1, i-1); 
8. SEARCH IN SORTED ROTATED ARRAY - 1. Naive - Linear - O(n)
				  - 2. BS (logn) - find mid - decide left or right half rotated -upadte low and high
					while (l<=h { int m=(l+h)/2;  if(a[m]==x) ret m; 
								      if(a[l]<a[mid] )  left halg sorted, search if value present in left half
									{ if( x>= a[l] && x<a[mid]) h = m-1; else l =m+1; }
								      else  // right half is sorted , seracj if value present in rigth half
									{ if( x>= a[m] && x<a[h])  l= m+1; else h=m-1; }
9. FIND PEAK ELEMENT - 1. Naive - Linear -  On)
		       2. Bs -  Idea - if a[mid-1] >a[m] agr aisa h to leaftmost se mid-1 tak me atleast one peak will be present- loop the following under whil(l<=h)
				m==0 && arr[m+1]<=arr[m] handles the first elenment
				m==0 && m==n-1; contains only one ele
				m==n-1 && arr[m-1] <=a[m] handles the last ele.
				else if (m>0 && a[m-1]>=a[m]) h=m-1; else l=m+1;
10. TWO POINTER APPROACH. Q- find if there is  a number in array with sum == x
			1. Naive(unsorted)-O(n^2)
			2. Hashing(unosrted) -O(n)  ASC:O(n) -put one by one - Before puttin check if sum-arr[i] presernts in hash table
			3. Two ptr(Sorted arr)O(n) - int l=0; r=n-1; while(l<r)
						{ if(a[l]+ a[r] >x) r--; else if( a[l]+a[r] <x) l++; else ret true;}
Q. Whihc way to prefer for unsorted arr  ? HASHING

11. TRIPLET WITH GIVEN SUM - run is pair for( i= 0 ;i<n-1; i++) for X =  x-a[i]
			for( i=0 ;i<n-2;i++) { if(isPair(a,i+1,n-1,sum-a[i]) ret true;}
EG: {2,3,4,8,9,20,40} sum = 32; itr 1 = if isPair true for 32-2 = 30 => triplet is available  else move to next ele.

12. MEDIAN OF TWO SORTED ARRAYS: Naive - O((n1+n2)*log(n1+n2)) ASC -O(n1+n2)
				eff -  BS O(log(n1+n2))
13. REPEATING ELEMENTS
14. MAJORITY ELEMENT

SORTING : stable = IBM+
1. BUBBLE: BEST O(n) Worst(n^2)
2. SELECTION: Best 0(n) 0 swap with itself elements : W O(n^2)
3. INSERTION: Best O(n) -  W(O(n^2))
4. MERGE : TC :O(nlogn) ASC: O(n)
5. UNION OF TWO SORTED ARRAYS : Naive M1: O(m*n) - M2: O(m+n)
6. INTERSECTION OF TWO SORTED ARRAYS: Naive M1: O(m*n) - M2: O(m+n)
7. Count INVERSION IN ARRAY: use merge: TC:O(nlogn) ASC :  O(n)
8. QUICK SORT - 
	naive part -  two for loop to separate the min in left side and max in right side.
	Lomuto - if found smaller ele < pivit => just increase the window of smaller ele and proceed
		p-always last ele
			int i =l-1; for( j =l ; j<r-1;j ++){ if(a[j] < pivot ) {i++ ; swap(a[j],a[i]} } swap[a[i+1],a[h]) return i+1;
	Hoares -
		p - always the first ele
	i want: ele<pivot in left and ele>pivot in right = > So just search the ele>pivot in left and ele<pivot in right and swap them. TWO POINTER APPROACH.
	int i =l-1; int j =h+1;
	while(true) { do{i++;} while(a[i]<pivot) } do{j--;} while(a[j] >pivot)  if(i>=j) return j;  swap(a[i],a[j]);}
Lomuto v/s Hoares
1. pivot at correct pos : ret the  index of pivot		-		pivot not at its correct posn.
2. better due 1.			
3. but more comparison ( linear traversal)			-		two pointer approach (3 times faster than lOmuto)
4. Not stable							- 		not stable
Naive - three traversal but stable

QUICK SORT  
a. divide and conquer - inplace  - cache friendly -avgO(nlogn) W:O(n^2)- unlike merge, its tail recursive(Good)  - s
b. since we use hoares (not stable) , so if want stable use Merge Sort else Quick Sort.
Lomuto 					Hoares
int p = partition(arr,l,h)		int p = partition(arr,l,h)
Qsort(arr,l,p-1)			Qsort(arr,l,p)
Qsort(arr,p+1,h)			Qsort(arr,p+1,h)

Analysis of Quick Sort
Best -   O(nlogn) - array divide into equal halves => len(tree) = logn
Worst -  O(n^2) - partition divide in such a way that only 1 ele in one side
Avg  - O(nlogn) - unfair decison - cn - cn/10 and 9cn/10 type....
space - Worst -max fn call at any moment - number of ele => O(n)
	Best - array into two halves - theta(logn) 

CHOICE OF PIVOT AND WORST CASE(sorted) OF QUICK SORT -  p = random(l,r) - > Lomuto -  swap(a[l],a[p]) -> hoares -swap(a[p],a[r])
TAIL CALL ELIMINATON IN QUICK SORT- after partition which halves has less ele recur only for that part. dO call elimination for the larger  part.  - optimize space

9. Kth SMALLEST IN ARRAY : m1 -O(nlogn)  sort -ret arr[k-1]
			   m2 - O(n^2) if k==n else O(Kn)~O(n) - do lomuto k times, if(p==k-1) ret arr[p];
				while(l<=r) { int p =  partition(arr, l, h) ; if(p==k-1) ret arr[p]; else if(p<k-1) l=p+1; else r=p-1; }
10. CHOCOLATE DISTRIBUTION PROBLEM
11. SORT AN ARRAY WITH TWO TYPES - M1 - O(n) - three traversal - M2 -O(n) Lomuto or Hoares
12. SORT AN ARRAY WITH THREE TYPES - sort array of 0,1,2 - Three way prationing - Partition around a Range
				   M1- Naive O(n) - four traversal( three opertaion + 1 update)  ASC:O(n)
				   M2-Eff - DUTCH NATIONAL FLAG ALGO: TC: O(n)- 1traversal- ASC:O(1)
					l0 =1;h=n-1; i=0;
					while(i<=h)
					{ if (arr[i] ==0) swap(a[i], a[l0]); l0++; i++;
					  if (arr[i] ==1) i++;
  					  if (arr[i] ==2) swap (a[i],a[h]); h--;
					}

13. MINUMUM DIFFERENCE IN ARRAY -  M1 - O(n^2) consider every pair and return min
				   M2 - O(nlogn) return min diff of adj element
14.MERGE INTERVALS- (left to)
15. MEETING MAX GUESTS - sort (arr) , srot(dept); while(i<n && j<n) { ifa[i]<=dept[j]) curr++;i++;  else {curr--;j++;}  res =  max(curr, res);
15. CYCLE SORT - Worst -O(n^2) - does min memory writes 
20 40 50 10 30 - index 0->1->3->-0; cycle complete similarly for every index
for(i=0; i<n-1; i++){
 int item =a[i]; int pos=i; for( j=i+1;j<n;j++) { if(a[i]<item) pos++;} swap(item,a[pos]);    0->1  item becomes 40 a[pos(1)]=20

we need to find a cycle; cycle found when pos==i
while(pos!=i)
{ pos = i; // since sorted before i;
	for(j =i+1; j<n; j++) { if(a[j]<item) pos++; } swap(item, ar[pos]);
}
 arr 		 item	ar[pos]	pos=0
20 40 50 10 30   20		1
20 20 50 10 30	 40		3
20 20 50 40 30	 10		0
	
16. HEAP SORT
17. COUNTING  - subroutine for Radix 
SORT Naive O(n+k)						Eff-		
	arr={1,4,4,1,0,1} => count={1,3,0,0,2} 				same					tc  : O(n+k) ASC: O(n+k) count[k], output[n] -not a comp based - stable
	just print the ith index count[i] times 		find prefix of count { 1,4,4,4,6}
	ind =0;							int output =  new int [n]  
	for( i=0;i<n;i++)					for( i =n-1; i>=0;i--)
	{for(j=0;j<count[i' ; j++)  { arr[ind] =i; ind++;}	{ output[ count[arr[i]] -1 ] =arr[i]; count[arr[i]]--; }
								update arr[i] =output[i]
18.  Radix sort TC O(d*(n+k))  d = no of digits in max num
319 212 6 8 100 50 rewrinting with leading zeros - > 319 212 006 008 100 050
						 - > 100 050 212 006 008 319
						 - > 100 006 008 212 319 050
						 - > 006 008 050 100 212 319

1. find max  -O(n)
2. run the num of digits time counting sort for( exp =1; max/exp>-; exp*=10) { counting Sort(arr,n,exp);} 
3. countiungSort(arr, n, exp){  1. find count[i]; for( i=0 ;i<n;i++) {count[(arr[i]/exp)%10]++ ;}
				2. prefix count[] => count[i] =Num(of elements whose last digit is <=i)   for( i=1 ;i<10;i++) {count[i] +=count[i-1];}
				3. traverse from right - Stable for( i=n-;i>=0;i--) {  output[ count[(arr[i]/exp)%10] -1] = arr[i]; count[ (arr[i]/exp)%10 ]--; }
				4. update arr[i] to output
			     }
19. Bucket Sort - worst case - 2 bucket formed and push entire ele in it - O(nlogn)
		  Best case  - 1 element in each bucket - O(n)
1. find max value; 2. make bucket;   for(i=0 ;i <k;i++) bkt.add(new ArrayList<Integer>()); 
3. fill bucket;for(i=0 ;i <n;i++) { int bi = (k*arr[i[)/max_val; bkt.get(bi).add(arr[i]; }
4. sort bucket; for(i=0 ;i <k;i++) { CollectionsSort(bkt.get(i));
5. join bucket ; join arraylist for(i=0 ;i <k;i++) { for(j=0 ;j<bkt.get(i).size();j++) { arr[ind++] = bkt.get(i).get(j)++; }



QUEUE
1. FIFO
Applications
a. single resource and multiple consumer EG ticket counter
b. In OS,
	Sephamores - there are sleeping processes waiting in Queue, as resource not available, whenever avaialable one of the processes wakes up and use the resource
	FCFS scheduling - multiple processes wanna use single processor, whichever process comes first served first
	Spooling - Used in printers, prints one page at a time
	buffer for devices like keyboard 
c. Synchronization b/w slow and fast devices -Keyboard slow device=> typing also slow and CPU is fast.
 soln: all ch u type goes into the queue, CPU comes in a cycle and quickly takes up all the ch.
d. IN Computer Networks,
	Synchronization maintained by Routers - server providing services to multiple consumers.
e. Variation of Queue
	Dequeu, Priority Queue(eg, Assigning priopities to pateints), Double Ended Proirity Queue(eg. like to know the lowest proiroty patient, Dr can leave now, he might not need to serve).

f. Summary : Queue data structure used in two situtations
	Single resource - multiple consumers(want to serve in FCFS manner)
	Need to synchronize slow and fast devices

1. IMPLEMENTATION OF QUEUE WITH ARRAYS
	class Queue{int size, cap; int arr[], Queue( int cap) { this.cap = cap; size =0; arr=new int[cap];} 
	boolean isFull() { return (size==cap);}  o(1)
	boolean isEmpty() { return (size==0);}	O(1)
	int getFront() { if(isEmpty())ret -1; else ret 0;} O(1)
	int getRear() { if(isEmpty())ret -1; else ret size-1;} O(1)
	void enqueue(int x) { if(isFull() ret; arr[size]=x; size++;} O(1)
	int dequeue() { if(isEmpty() ret -1;  for( i=0;i <size-1;i++) arr[i]=arr[i+1];} O(N)
		}

2. eff sol -Why ? to make dequeue in O(1)  - Use of Circular Array -- all op O(1)
	int getFront() { if (isEmpty()) ret -1; return front;}
	int getRear() { if(isEmpty()) ret -l; return (front+size-1)%cap; }
	void enqueue(int x) { ifisFull() ret; int rear =getRear(); rear=(rear+1)%cap; arr[rear] =x; size++;}
	void dequeue() { if(isEmpty() ret; front = (front+1)%cap; size--;}
3. LINKED LIST IMPLEMENTATION	
	enqueue - append at last of LL.
	dequeue - Delete head Of LL. 
	Idea : to perform above operations in O(1), need to maintain two ref.
	class Node{ int data; Node next; Node (int data) { this.data=data; next=null;} }
	class Queue { Node head, rear; int size;
	void enqueue(int x) { Node newnode = new Node(x); size++; if(head==null) {head=rear=newnode; ret;}  rear.next=newnode; rear=newnode; }
	int dequeue() {if(head==null) ret null; size--; Node temp=head; head =head.next; if(head.next=null) rear=null;   return temp.data; }
	Node getFront() { return head;}
	Node getRear() { return rear;}
	int getSize() { return size;}
		}
QUEUE IN JAVA
1.ll and Arraydeque imp Queue imp Collection
2.intialization of Queue
Queue<Integer> q = new LinkedList<>(); Worst O(1)
Queue<Integer> q = new ArrayDeque<>();  // better, O(1) access, cache friednly as contiguous - faster - Amortized O(1) -> op involving resizing of array take linear time.
3.Functions that returns null v/s throws exception
 peek()	-	element()
 offer()- 	add()
 poll()	- 	remove()

4. IMPLEMENTATION OF STACK USING QUEUE
MAKE Q1; 
PUSH K LIYE JUST - { reverse(q1);  q1.add(x); }
POP - { reverse(q1) ; int temp = q1.remove(); }  
REVERSE()

5. REVERSE A QUEUE
Iterative app-
 a. create stack
 b. while(q not empty) st.push(q.remove());
 c. while(st not empty) q.add(st.pop()); 
 d print q for( int x: q) print(q+" ");

Recursive-
void rev(Queue<Integer>){ if(q.isEmpty() ret; int x = q.poll(); reverse(q); q.add(x); }

6. GENERATE NUMBER WITH GIVEN DIGITS => n=7; 5 6 55 56 65 66 555 ....
a. create q, q.add('5'); q.add('6');  
b. for(i=0;i<n;i++) { String curr = q.poll(): print(curr+" "); q.add(curr+"5"); q.add(curr+"6"); }


Deque Data Structure - in java it is implemented using LL
1. Implementation
a. LL  - that too DLL WHY ? deletion from tail cannot be in O(1)
b. Array - Circular array with front and rear indexes for every op to be in O(1)

2.Applications
a.Deque can be used as both Stack and Queue
b. Maintaining History of Actions - whenever vis add in rear of Deque, and if buffer becomes full, start removing from front
c. A STEAL PROCESS sCHEDULING ALGO - consider multiple process within the queue of P1 and P2. if P2 is free, it can pick some processes from rear of P1 which normal Queue does not allow
d. IMPLEMENTATION PROIRITY QUEUE WITH TWO TYPES OF PRIORITY
e. MAX/MIN OF ALL SUBARRAYS OF SIZE K IN AN ARRAY

1. ARRAY IMPLEMENTATION
class Deque{ int size, cap; int arr[], Deque(int cap) { this.cap=cap; size=0; arr=new int[cap];}
boolean isFull(){ return (cap==size);}
boolean isEmpty() { ret (size==0);}
void insertRear(int x) { if (isFull() return; arr[size]==x; size++;}
void deleteRear() { if(isEmpty() ret; size--;}
void insertFront(int x) { if (isFull()) ret; for(i=size-1;i>=0;i--) {arr[i+1]=arr[i];} arr[0]=x; size++; }   O(n) - not good
void deleteFront(){ if(isEmpty()) ret; for(i=0;i<size-1;i++) {arr[i]=arr[i+1]; size--;}			     O(n) - not good
int getFront(){ if(isEmpty()) ret -1; retrun 0;}
int getRear(){ if(isEmpty()) return -1; return size-1;}

2. eff sol - use of Circular array to make insertFront and deleteFront in O(1).  rear is always  (front+size-1)%cap

int getFront() { if(isEmpty()) ret -1; retrun front; }
int getRear(){ if(isEmpty()) return -1; return (front+size-1)%cap;}
void insertFront(int x) { if (isFull()) ret; front = (front-1+cap)%cap; //move back arr[front]=x; size++;}
void deleteFront(if(isEmpty()) ret; front=(front+1)%cap; size--;}
void insertRear() { if (isFull() return; int new_rear = (front+size-1+1)%cap; arr[new_rear] =x;}
void deleteRear() { if (isEmpty()) ret; size--;}  // since there is no ptr for rear, we are always finding it using front and rear.


3.Methods in Deque
Throws exception	v/s	return false/null
addFirst()		-	offerFirst()
addLast()		-	offerLast()
removeFirst()		-	pollFirst()
removeLast()		-	pollLast()
getFirst()		-	peekFirst()
getLast()		-	peekLast()

REDUNDANT FUNCTIONS - AD implements(imp) deque interface imp Queue interface imp Collections and provides main finctionalities of Stack class.
Queue: it is a interface - insert at rear, delete from front - FIFO
add()  same as addLast()		-	offer() same as offerLast()
remove() same as removeFirst()		- 	poll()  same as pollFirst()
element() same asgetFirst		-	peek()  same as peekFirst()

Stack : LIFO - it is not an interface- its a legacy class inherits vectors.
push() same as addFirst()
pop() same as removeFirst()
peek() same as peekFirst()

So, total 21 methods can be used in Deque.
WHY IT IS RECOMMENDED TO USE AD AS STACK AND QUEUE
ANS.
Use AD as Stack : AD is faster then Standard Stack Class - because stack uses vector which is threadsafe and issue of overhead occurs.
Use AD as Queue : Queue used LL implementation where AD uses array implementation (faster)
Use AD as Deque : Deque implementaion - LL and AD(preferred and faster)

4. Traversing in a Deque
a. Using iteretors; from first to last
Iterator it = d.iterator();
while(it.hasNext())
	println(it.next()+" ");

from last to first - Iterator it = d.descendingIterator();
b. using for loop - first to last
for( int x:d ) println(x+" ");

 
5. DESIGN DATA STRUCTURE supports following op in O(1)
a insertMin(x) dq.offerFirst() 
b insertMax(x) dq.offerLast
c getMin() -dq.peekFirst()
d getMax() - dq.peekLast()
e extractMin() - dq.removeFirst() 
f extractMax() - dq.removeLast()

6 MAXIMUM OF ALL SUBARRAYS OF SIZE K.
m1. Naive - O(n^2) ASC -O(1)
M2 - O(n) ASC O(1)
a. keep putting elements in the dequeu addFirst -if smaller ele than prev keep in coming.
b. if larger ele comes then prev, keep on removeLast
10,8,5,12,15,7,6
i=0; 0
i=1; 0 1 
i=2; 0 1 2  print(10)
i=3; 3		12
i=4; 4		15
i=5; 4 5 	15
i=6; 4 5 6	15

7. FIRST CIRCULAR TOUR
50 10 60 100  - i=0 curr_pet=20 > i=1 c_p=10 > i=2 c_p=-30 >> start=3; prev_pet=-30; c_p =0; > i=3; c_p =90 ; return (c_p+prev+pet)>=0 ? start+1:-1 
30 20 100 10


STACK -Lifo
1. Array imp-
	class MyStack() { int arr[],int cap, int top; MyStack(int cap){this.cap=cap; top=-1; arr=new  int[cap]; }
	void push(int x){ if(top==cap-1) ret; top++; arr[top]=x;}
	void pop() {if(top==-1) ret; int res=arr[top]; top--; return res;}
	void size() { return top+1;}
	int peek() { if(top==-1) ret; return arr[top]; }
	boolean isEmpty() { return (top==-1);}
	boolean isFull() { return (top==cap-1);}
			}

Problems : No dynamic resizing - 
Soln :	Use arrayList - No need to declare the cap
	classMyStack { ArrayList<Integer> al = new ArrayList<>(); 
	void push( int x) { al.add(x); }
	void pop(){ if(isEmpty()) ret; int res =al.get(al.size()-1); al.remove(al.size()-1); return res;}
	int peek() { return al.get(al.size()-1);
	boolean isEmpty() { return al.isEmpty(); }
	int size(){ return al.size();}
			}
3. Stack using LL -
idea: push - append at head 	-O(1)    -- if appended at last of LL then pop => remove from tail which will take O(n) -so preferred to append at head
      pop  - remove from head	- O(1)
      peek - return head of LL
	class stackNode { int data; stackNode next; stackNode(int data) { this.data=data; next=null;} }
	class myStack{ stackNode head; 
	void push(int x) { stackNode newnode = new stackNode(x); if(head==null) { head=newnode; ret;} else{ StackNode temp = newnode; temp.next=head; head=temp; }
	int pop() { if(head==null) return -1; stackNode temp = head; head = temp.next; return temp.data; }
	void peek() { if(head==null) ret -1; return head.data; }
4. Applications
	a. Function calls
	b. Checking for balanced parentheses
	c. Infix to postfix/prefix
	d. Evaluation of Postfix/Prefix
	e. Undo/redo or forward/backward op.
	f. Stock span problem
Stack ext Vectors ext List ext Collections
AD ext Deqeu ext Queue ext Collections

Q Why deque preferred over Stack?

5. BALANCED PARANTHESES
	ArrayDeque<Character> st = new ArrayDeque<>();
		for ( int i =0 ;  i <n ; i++) { if(str.charAt(i)=='(' || [' || '{') {st.push(str.charAt(i));}
						else { if (st.isEmpty()) ret false;							// handles ')' or '(()))'
							else if( str.charAt(i)=closing && st.pop()==same closing) ||... continue;
							else return false; }								// handles '(}'
						} return(st.isEmpty()); 	 					
6. IMPLEMENT TWO STACKS IN ARRAY
NAIVE -divide array into two halves
O(1) AS:O(cap)  stack1 from leftmost and stack2 from righmost

7. K stacks in Array

8.PREVIOUS GREATER ELEMENT
	a. make a stack
	b. push arr[0] ; print(-1);
	c. for(i=1;i<n;i++) { jab v koi greatethanequal element mile than st.peek() - then pop from st.  print (ans)  where ans =st.isEmpty() ? -1 : st.peek(); , then push a[i]; }
			    { while(!st.isEmpty() && arr[i]>=st.peek()) {st.pop(); ans = st.isEmpty() ? -1:st.peek() ;print ans();n}  st.push(arr[i]); }

9. Stock Span - number of days  on left side <= day itself
	a. make a St
	b. push(arr[0] ) prinr(1);
	c. for( i=1;i<n;i++) { while{ a.agr arr[i] >= st.peek() keep on popping b. span =st.isEmpty() ? i+1 : st.peek(); , c. then push i; }  print(st.peek());
			exactly as above;

10. NEXT GREATER ELEMENT 
	a. make a st
	b. do the q9 from the right; an aux arr will be req - int ans[] =new int[n]; int ind=n-1; st.push(a[n-1]) , ans[index]=1-; index--;
	c. for n-1 the answer will be -1, since no ele present further. 
	d. traversing from i =n-1; t>=0 ;i-- { while(!st.isEmpty() && arr[i]>=st.peek()) { st.pop(); } int res = st.isEmpty() ? -1 : st.peek(); ans[index]=res; index--; st.push(arr[i]); }

11. LARGEST RECTANGULAR AREA IN HISTOGRAM
	naive -m1 -O(n^2) AS:O(n)
	idea;for a part i , traverse left such that arr[left]>=arr[i]; curr+=arr[i]; then traverse right such that arr[righ]>=arr[i] and curr+=arr[i]; 
	after each iterarion of i, res=Math.max(res,curr);
	
	eff -M2 -O(n) 3 traversal AS: O(2n)
	a. res=0;
	b. find prev samller element (store index in ps[i])  of arr[i] and next smaller element (store indes in ns[i]) of arr[i];
	c. curr=arr[i]; curr+=(i-ps[i]-1) *arr[i] ; curr+=(ns[i]-i-1)*arr[i];


LINKED LIST - 
WHY ? 
a. size fixed and pre-allocated , now insertion at end will take O(n)  - LL no preallocation
b. insert/ del in middle in array is costly     in LL - just change the ref
c. Implemetation of Dequue, Queue, is comples in Array(Circular Array functionlaties) , but also faster and cache friendly than LL

d. scenario - given a sequence of characters, if encountered x , insert 5 times y.
e. merger sort in array - take aux space
   merger sort in LL - no Aux space


Trees
a.Aplications
	rep heirarchial str - org str , folder str, XML(html content(json obj) , in oop(inheritance)
	BST, Binary heap, B and B+ tree in DBMS, Spanning and Shortest path tree in comp N/w , parse tree and expression tree in Compiler
	Trie, Suffix Tree, Binary Index Tree, Segment

1. BINARY TREE
class Node{int key, Nodel left, Node right Node(int k){ key=k;} }
class Test { main{ Node root = new Node(10); root.left(20); root.right(30); root.left.right(40); }

2. TREE TRAVERSAL
BREADTH FIRST (LEVEL ORDER)
DEPTH FIRST( Inorder (Lt,root,Rt) , preOrder(root,Lt,Rt), PostOrder(Lt,Rt,root)

Inorder(Node root) { if(root!=null) inoder(root.left); print(root.data);  inorder(root.right); }

3. HEIGHT OF BINARY TREE  TC :  O(n) SC :O(logn) max function call at a time
int ht(Node root) { if(root==null) ret 0; else ret Math.max(ht(root.left), ht(root.right) + 1);

4. PRINT NODES AT K DISTANCE  - to print nodes at k+1 level.  TC : O(n) SC : O(h)
idea :   make a fun( root , k )  - dicerement k as we traverse to next level and when k reaches 0 we print the nodes. => call recursively left and right with k-1

void fun( Node root, k) { if(root==null) return ; if (k==0) print(root.data+ " ") else {fun(root.left, k-1); fun(root.right,k-1); } }

5. LEVEL ORDER TRAVERSAL
Idea :  1. use ht and print nodes at k dist
	2. use Queue data str - a. enqueue the root into q  b. while deqeueu the items , enqueue their children(i.e. next level)

code :	1. TC: O(hn) SC:(h)
	 int ht= height(root); for(i=0;i<ht;i++) { printKDist(root,i); }    
	
	2. TC : O(n) - for every node we enqueue and dequeu once. 
	   SC : O(w) - width of Binary tree 
	 Make a queue Qeuue<Node> q = new LinkedList<>();
	  { if(root==null) return;  q.add(root)
	    while(!q.isEmpty()) { Node curr = q.poll(); print(curr); if(curr.left!=null) q.add(curr.left) ; if(curr.right!=null) q.add(curr.right); }
	  } 

5a. LOT(Part 1) Line by Line 
Idea :  1. along with root, push null;    TC : O(N+h) ~ O(n)  SC:O(width)
	 And if null encountered while poll, print new line , push another null  :
Code : 	{ if(root==null) ret; q.add(root); q.add(null); 
	  while(!q.isEmpty()) { Node curr = q.poll(); if(curr==null) { println(); q.add(null);} 
						      else { print(curr); if(curr.left!=null) q.add(curr.left) ; if(curr.right!=null) q.add(curr.right); }
			       } } 

	 TC : O(N)  SC:theta(width)
 	2. Make a queue Qeuue<Node> q = new LinkedList<>();
	  { if(root==null) return;  q.add(root)
	    while(!q.isEmpty()) { int count=q.size();   for( i=0; i<count;i++) { 
				Node curr = q.poll(); print(curr); if(curr.left!=null) q.add(curr.left) ; if(curr.right!=null) q.add(curr.right); } println();
	  } 

6. SIZE OF BINARY TREE
Idea :  1. Itereative: while enqueing node in Level Order Traversal, count++ while enqueue each node.
	2. Recursive: int size(Node root){ if(root==null) ret 0; else return 1+size(root.left) + size(root.right); 

7. MAXIMUM IN BINARY TREE
Idea : since there is no relation b/w the value of nodes, => have to visit each node(same as finding size of BT) and update the max
	TC : O(n) since visiting each node , SC : O(ht) - max fn call at a time
	int getMax(Node root) { if(root)==null return Integer.MIN_VALUE; 
				else Math.max(root.data, Math.max( (getMax(root.left) , getMax(root.right) )); }

8. PRINT LEFT VIEW OF BT.
Idea : 1. iterative - print first node in level order traversel => TC : O(n) , SC :O(width) 
	a. make a queue 
	b. insert first ele 
	c. while q not empty - store the size of level(size of queue) 
	d. iteratate through size and poll the ele(add their children) -> if i==0 print curr.data a 
	void fun(Node root) {  if(root)==null ret; Queue<Node> q = new LinkedList<>(); q.add(root);
	while(!q.isEmpty()) { int count =q.size(); for(i=0;i<count;i++) { Node curr=q.poll(); if (i==0) print(curr.data+" "); if(curr.left!=null) q.add(curr.left); (same for right); } } }

	2. Recursive - TC :O(n) - visting each node , SC : O(h) - max fn call at a time
	a. create ml -1; lev=0 for root and keep incrementing as move to next level
	b. for each level if ml<l print root.data and call recursively for root.left and root.right.
	static int ml=0;
	fun(Node root, int lev) {  bc ; if(ml<l) {print(root.data+ " "); ml =lev; } fun(root.left,lev+1); fun(root.left,lev+1); }
	void PrintLeft(Node root) { fun(root,1); } 

9. CHILDREN SUM PROPERTY - sum of child data== parent data
Idea :  a. BC :  true - if root is null 2.true if both childs are null
	b. what to do - > sum= root.left.data+root.right.data ; if(summ==root.data) ret true;
	c. need to check for all nodes -> recursive call for fun(root.right) && fun(root.left)

TC:O(n) - visiting each node - SC :O(h)- max fn call at a time
Code : func(Node root) { bc 1. if(root)==null ret true; bc 2. if(root.left==null && root.right==null) ret true;
			int sum = 0; if(root.left!=null) sum+=root.left.data;  if(root.right!=null) sum+=root.right.data;
			retrurn (root.data==sum && fun(root.left) && fun(root.right) );
			}

10. cHECK FOR BALANCED BINARY TREE- for every node abs(lht-rht) > 1 ; ret -1;
Idea : 1. TC -O(n^2) SC -O(n)
	call ht func for evey node
	2. TC -O(n) , SC-O(n)
	int isBal(Node root) { if(root==null) ret null; int lh=isBal(root.left); if(lh==-1) ret-1;   int rh=isBal(root.right) if(rh==-1) ret-1;
				if(Math.ab(lh-rh)>1) ret -1;  else return Math.max(lh,rh)+1; }

11. MAX WIDTH OF BT
Idea :Level order - upadte  max with q.size();  = > TC :(n) , SC-O(width)

12. CONVERT A BT TO DLL ORDER(INORDER)
Idea : fdo preoder and add the node in dll
	Node BtoDll(Node root) { if(root)==null return; Node head = BtoDll(root.left);
			if(prev==null) head=root; else{ root.left=prev; prev.right=root;} prev=root;  BtoDll(root.right); ret head; }
TC: O(n) , SC:O(ht)

13. CONVERT BT FROM INORDER AND PREORDER
IN 20 10 40 30 50  
PR 10 20 30 40 50  - > ROOT IS 10 FOR SURE- >so search 10(store it index in inInd) in in[] and call recursively for root.left=(in,pre,is,inInd-1)
				and root.right(in,pre,inInd+1,ie)
TC : O(n^2) - for every node we are doing n work
int preIndex=0;
Node ctree(int in[], int pre[], int is, it ie) { if(is>ie) ret null; Node root=new Node(pre[preInd++]);
int inInd; for(i=is;i<=ie;i++){if(in[i]==root.data) {inInd=i; break;} }
root.left=fun(in,pre,is,inInd-1); root.right=fun(in,pre,inInd+1,ie); ret root; }

14. TREE TRAVERSAL IN SPIRAL FORM
M1. using level order - maitain a flag - for first level add in q and print the q. 
					- for second,4th,6th,... push in stack and pop.
TC:O(2n) - SC:O(width) here, every item is going inside and then coming outside.

M2.  eff - O(n) - item goes exaclty once inside and out.
a. push root in s1.
b. while any of the stacks is not empty 
	while(!s1.isEmpty()) pop first node and print it , add its children to s2.
	while(!s2.isEmpty()) pop first node and print it , add its childrin in s1.
Node if zig zag is left->right : s2 me first add right then left child  child -in s1 first add left child then right ...... and vice versa for zig zag rigth>left.

15. DIAMETER OF BT.
M1. find the following for every node - max(1+lh+rh)   - TC:O(n^2)Skew trees, SC:O(h)
int ht(Node root) { if(root==null) return null; retrun 1+max(height(root.left),height(root,right)); }
int diameter(Node root){ if(root==null) ret null; int dl =1+height(root.left)+height(root.right); int d2=daimeter(root.left);  int d3=diameter(root.right); ret max(d1,d2,d3); }

M2.
Store ht of every node and store it in map - Adv-need to write just ht fun. => TC :O(n) SC:O(n)-hasmap for n nodes
HashMap<Node,Integer> mp =  new HashMap<>();
Disadv - extra overhead for lookin into hash table.

M3. while finding ht of every node , keep track of max(1+lh+rh)  => TC:O(N) , SC:O(H)
static int res=0; int ht(Node root) { if(root==null) ret 0; int lh=ht(root.left); int rh=ht(root.right); res=max(res,1+lh+rh); }

16. LOWEST COMMON ANCESTOR
M1. TC:O(3N) ,SC:O(N)
a. store all the nodes from root - node 1 in AL1 -findPath()
b. store all the node from root - node2 in AL2.
c. run a for loop from i=0; i<al1.size()-1 && i<al2.size()-1
	obv, al1.get(0)==al2.get(0)=root - so check { if(al1[i+1]!=al2[i+1]) ret al1[i]; }

boolean findPath(Node root, AL<Node>,int n){ if(root==null) ret false; p.add(root); if(root.data==n) ret true;
						if(findPath(root.left,p,n) || findPath(root.right,p,n) ) ret true;
						p.remove(p.size()-1) ret false;     // ele nai mila but root is still added in AL, remove it }
Node lca() ... bana lena

M2. Node lca(Node root,int n1, int n2) { if(root)==null ret null ; if(root.data==n1 || root.data==n2) ret root; Node left=lca(root.left,n1,n2) ; Node right=lca(root.right,n1.n2);
					if(left!=null && right!=null) ret root;
					if(left!=null && right==null) ret left;  else ret right; }
TC :O(n) , SC:O(h)

17. BURN A BT FROM LEAF

18. COUNT NODE IN COMPLETE BT

19. SERIALIZE (tree to String/Array) - DESERIALIZE(vice-versa)
App:    a. Sharing Tree DS over n/w
	b. Passing tree as test cases in gfg- conversion into Str/array.
	c. Generation of test cases  - Serialize
	d. User read the program - Deserialize - to construct a tree

Node deserialize(AL<Integer> arr)

Deserialize - TC:O(N) , SC:O(h)
M1. to construct BT back - Req two traversal - In&pre or In&post
M2. Use specail marker for null(say -1)
root=10 root.left=20 root.right=30 => 10 20 -1 -1 30 -1 -1 => Deserailize(Apply Preorder)
static final int EMPTY=-1; int index=0;
Node des(AL<int> arr) { if(index==arr.size()) ret null; int val=arr[index++]; if(val==EMPTY) ret null; Node root=new Node(val); root.left=des(arr); root.right=des(arr); ret root; } 

SERIALIZE  - writing pre order - TC: O(n) - SC:(n+n+1) -if Bt has n nodes ,then n+1 nulls
void serialize(Node root, AL<Integer> arr) 
{ if(root)==null { ar.add(Empty) ; return; } arr.add(root.data); serialize(root.left,arr); serilize(root.right,arr); }


20. ITERATIVE IN ORDER  TC :O(n) SC:O(H)
void Itin(Node root){ if(root==null) ret null; Stack s; Node curr==root; while(curr!=null || !s.isEmpty()) { while(curr!=null) { s.push(curr.data) ; curr=curr.left ;}
													     curr=s.pop(); print(curr.data); curr=curr.right; }  }
21. ITERATIVE PRE ORDER
Space Opt Preorder  - TC:O(n), SC:O(h)
Idea :  store only the right child to Stack.
 { Node curr = root; while(curr!=nul || !st.isEmpy()) {  while(curr!=null) { print(curr.data); if(curr.right!=null) st.push(curr.right);  curr=curr.left } 
							if(!st.isEmpty() curr = st.pop(): }  }

BINARY SEARCH TREE
Adv: search/insert/del/findclosest - logn , sortedTraversal(Inorder) - O(n)
In java -implemented usig Tree Map And treeSet
1. for evey node, key in left < key in right 2. all keys r considered distinct 3. like LL, it is Linked data Structure(LDS)
Adv : In LDS, not require resizing, for del,ins....
Disad: Not chache friendly, items as diff location.

1. SEARCH IN BST - 
{ while(root!=null) { if(root.key==x) ret true; else if(root.key<x) root=root.right; else root=root.left;}  		   - O(logn) , SC:O(1)
{ if(root)==null ret false; if(root.data==x) ret true; else if(root.data<x) ret fun(root.right) else ret fun(root.left); } - O(logn) , SC:O(logn)

2. BST INSERT
Node insert(Node root, int x) 		- TC:O(logn) SC:O(1)
{ Node temp = new Node(x); Node parent=null; Node curr=null;
	while(curr!=null) { Node parent = curr; if(curr.data<x) curr=curr.right else if(curr.data>x) curr=curr.left; ret root; } 
	if(parent==null)  ret temp; // empty BST
	if(parent.data<x) root.right=temp; else root.left=temp;    return root; } 
Recursive:
{if(root==null) return new Node(x); if(root.data<x) root.right=inser(root.right,x)  else if(root.data>x) root.left=insert(root.left,x);  return root; }  - TC :O(logn) SC:O(logn)

3. DELETION IN BST   TC:  O(h) , SC:O(h)
a. Find closes greater value ( go right once and then left till !=null)
b. Copy that sccc key in root. 
c. Delete the succ key.
Node delete(Node root , int x)
{ if(root==null) ret null; if(root.key<x) roor.right=delete(root.right,x); else if(root.key>x) root.left=delete(root.left,x);
else { if(root.left==null) ret root.right; if(root.right==null) ret root.left; 
	else { Node succ= getSucc(root); root.key=succ.key; root.right=delete(root.right,succkey); return root; }  } 
} 
Node getSucc(Node root) { Node curr=root.right; while(curr!=null && curr.left!=null) curr=curr.left;  return curr; } 

4. Floor in BST  - TC:O(h) , SC:O(1)
Node flr( Node root, int x)
{ while(root!=null )  { if(root.data==x) ret root; else if(root.data>x) root=root.left; else{ res=root; root=root.right; }   } return res;
}

5. CEIL IN BST  - TC:O(h) , SC:O(1)
Node ceil( Node root, int x)
{ while(root!=null )  { if(root.data==x) ret root; else if(root.data>x){res=root; root=root.left; else{root=root.right; }  } return res;
}

6. SELF BALancing
 AVL - |lht-rht| <=1
 RED BLACK TREE -a. every node is red or black
		 b. root is always black
		 c. no two consecutive red
		 d. a node to its farthest descendant leaf , not more than twice( No. of nodes on the path to its closet leaf )
 TreeSet -  add, contains, remove, floor, ceiling, higher, lower, -all O(logn) , size ,isEmpty -O(1)
 TreeMap -put(K,V), removes(), containsKey, floor/ceiling/higher/lowerKey and floor/...Entry, - O(logn ,  size, isEmpty -O(1)

7. CEILING ON LEFT SIDE 
M1. O(n^2) O(1) - for a[0] print -1; traverse left for each a[i]  and find the greater to a[i] and update the min diff - then print a[i]+diff
print(-1) ; for(i=0;i<n;i++) {  int diff=MaxValue; for( j=0;j<i;j++) { if(arr[j] > arr[i]) diff=Min(diff,arr[j]-arr[i] ; if (diff=MaxValue) print(-1); else print(arr[i]+diff); } 

M2. O(nlogn) O(n)
 a. make a treeSet , insert arr[0];
 b. for( i=1;i<n;i++) { if(set.ceiling(arr[i]!=null) print(set.ceiling(arr[i]) ; else printp(-1);  set.add(arr[i]);} 

8.find kth smallest in BST
M1. do in order till count==k; print root.data;
M2. modify Node structure - Augmented BST - maintain a lcount-(no of nodes in left subtree) 
	 compare lcount+1 with k;
	a. lcount+1 > k ; recur to lst
	b. lcount+1 < k ; k=k-lcount-1 
	c. else return root;
Node Kthsmall(Node root, int k) { if(root==null) ret null; int count=lcount+1; if(count==k) ret root; if(couunt>k) ret kthsmall(roo,left,k); else kthsmall(root.right,k-count) ; }
Node insert - > do inorder - if inserting  at left- lcount+1; else no change
Node insert(Node root, int x) { if(root==null) ret null; if(x<root.data) {  root.left=insert(root.left,x) root.lcount++; } 
				else if( root.right = insert(root,right,x);   ret root; }
Node deletion -> if deletion at left- > root.lcount-- ; else no change ;

9. cHECK FOR BST
M1. TC: O(logn) , O(h) 
passa  range for every node; for root(-inf,+inf) ; left_child(-inf,root) ; right_child(root,+inf)

M2. O(h) , O(h)
maintain a prev and perform inorder(should be ascending) , and always check with prev to check the violation of ascending order. 
boolean iSBST(Node root) { if(root=null) ret true; if(isBst(root.left)==false)) ret false; if(root.key<=prev) ret false; prev=root.key;  ret isBST(root.right); } 

10. FIX BST WITH TWO NODES SWAPPED.
O(h) O(h)
void fixBST(Node root) 
{ if(root==null) return; fixBST(root.left); if(prev!=null && root.key<prev.key) { if(first==null) first=prev; second=root; }  prev=root; fixBST(root.right); } 
